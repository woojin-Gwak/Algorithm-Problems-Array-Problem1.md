# <분할 정복>
- *분할 정복(Divide and Conquer)**은 문제를 해결하는 알고리즘 설계 기법 중 하나로, 큰 문제를 여러 개의 작은 문제로 나누고, 그 작은 문제들을 독립적으로 해결한 후, 그 결과를 조합하여 원래의 문제를 해결하는 방법입니다. 이 방법은 다양한 문제에 효율적으로 적용할 수 있습니다.

### 분할 정복의 단계

분할 정복 알고리즘은 일반적으로 세 가지 단계로 구성됩니다:

1. **분할(Divide)**: 문제를 여러 개의 작은 문제로 나눕니다. 이 작은 문제들은 원래 문제와 비슷한 형태를 가집니다.
2. **정복(Conquer)**: 나눠진 작은 문제를 재귀적으로 해결합니다. 만약 문제가 충분히 작아졌다면, 직접 해결합니다.
3. **결합(Combine)**: 작은 문제들의 해결 결과를 결합하여 원래 문제의 해결 결과를 만듭니다.

### 예시

분할 정복을 사용하는 알고리즘의 대표적인 예시는 다음과 같습니다:

1. **병합 정렬(Merge Sort)**:
    - 분할: 리스트를 중간에서 두 개의 서브 리스트로 나눕니다.
    - 정복: 각 서브 리스트를 재귀적으로 정렬합니다.
    - 결합: 정렬된 두 서브 리스트를 병합하여 전체 리스트를 정렬합니다.
2. **퀵 정렬(Quick Sort)**:
    - 분할: 피벗을 선택하고, 피벗보다 작은 요소와 큰 요소로 리스트를 나눕니다.
    - 정복: 피벗을 제외한 두 서브 리스트를 재귀적으로 정렬합니다.
    - 결합: 피벗과 정렬된 두 서브 리스트를 결합하여 전체 리스트를 정렬합니다.
3. **이진 탐색(Binary Search)**:
    - 분할: 배열을 중간값을 기준으로 두 부분으로 나눕니다.
    - 정복: 중간값과 찾고자 하는 값을 비교하여, 왼쪽 또는 오른쪽 서브 배열에서 재귀적으로 탐색합니다.
    - 결합: 이진 탐색에서는 결합 단계가 따로 필요하지 않습니다. 결과를 반환하는 것으로 종료됩니다.

### 장점

- **효율성**: 많은 경우, 분할 정복 알고리즘은 문제를 훨씬 더 빠르게 해결할 수 있습니다. 예를 들어, 병합 정렬의 시간 복잡도는 O(nlogn)입니다.
    
    O(nlog⁡n)O(n \log n)
    
- **명확성**: 문제를 단계별로 나누어 해결하기 때문에, 알고리즘이 명확하게 설계되고 이해하기 쉬운 경우가 많습니다.

### 단점

- **재귀 호출의 오버헤드**: 재귀 호출로 인한 스택 메모리 사용과 함수 호출 비용이 발생할 수 있습니다.
- **결합 단계의 비용**: 결합 단계에서 추가적인 연산이 필요할 수 있습니다. 예를 들어, 병합 정렬에서 리스트를 병합하는 과정은 추가적인 시간과 공간이 필요합니다.

[백준 1629번: 곱셈 알고리즘 정리](https://www.notion.so/1629-130900cfb74d80baa561c8b32512a6b4?pvs=21)
