# [백준 2805번 : 나무 자르기](https://www.acmicpc.net/problem/2805)

주어진 나무들을 일정한 높이에서 잘라 필요한 나무 길이 합을 얻는 문제입니다. 주어진 나무들의 높이를 줄여서 합이 정확히 원하는 만큼 되는 최적의 자르기 높이를 찾아야 합니다. 이 문제는 **이진 탐색** 알고리즘을 통해 해결할 수 있습니다.

### 문제 분석

- `n`: 나무의 개수
- `m`: 필요한 나무 길이의 합
- `h`: 각 나무의 높이 리스트

우리는 `h`에서 특정 높이를 기준으로 잘라서 얻는 나무의 길이 합이 `m`과 같아지도록 해야 합니다. 자를 높이가 너무 높으면 필요한 만큼의 나무를 얻지 못하고, 자를 높이가 너무 낮으면 불필요하게 많은 나무를 자르게 됩니다.

### 이진 탐색을 이용한 풀이

이 문제는 탐색 범위가 크기 때문에 **이진 탐색**을 통해 최적의 자르기 높이를 찾아야 합니다. 이진 탐색을 적용하여 가능한 자를 높이를 줄여나가며 답을 찾습니다.

1. **이진 탐색 범위 설정**: 자를 수 있는 높이의 최소값은 `0`이고, 최대값은 가장 높은 나무의 높이입니다 (`max(h)`).
2. **중간값(mid)**: 높이를 이진 탐색으로 찾아나가는데, 자를 높이를 중간값 `mid`로 설정하고 그 높이에서 자른 나무들의 총합을 계산합니다.
3. **조건 확인**:
    - 나무를 자른 총합이 `m`보다 크거나 같다면, 더 높은 높이로 잘라서 자를 길이를 줄여볼 수 있습니다.
    - 자른 총합이 `m`보다 작다면, 더 낮은 높이에서 자를 수 있도록 탐색 범위를 줄여야 합니다.
4. **최종 결과**: 이 과정을 반복하면서 `m`에 가장 가까운 자를 높이를 찾습니다.

### 코드 구현

```python
python
코드 복사
import sys
input = sys.stdin.readline

# 입력 받기
n, m = map(int, input().split())
h = list(map(int, input().split()))

# 이진 탐색을 위한 변수 설정
low, high = 0, max(h)
result = 0

while low <= high:
    mid = (low + high) // 2  # 현재 자를 높이 설정
    total = 0

    # 나무 높이마다 자른 부분의 총합 계산
    for height in h:
        if height > mid:
            total += height - mid

    # 자른 나무의 총합이 필요한 길이보다 적다면 더 낮게 자르기
    if total < m:
        high = mid - 1
    else:  # 자른 나무의 길이가 충분하면 더 높게 자르기
        result = mid
        low = mid + 1

# 최종 결과 출력
print(result)

```

### 코드 설명

- `low`와 `high`: 자를 높이의 최소값과 최대값.
- `mid`: 자를 높이의 중간값.
- `total`: 중간값에서 나무를 자른 후 얻는 나무의 총 길이.
- **이진 탐색**을 통해 가능한 높이를 계속해서 좁혀가면서 최적의 자르기 높이를 찾습니다.

### 이진 탐색 흐름

1. 자를 높이의 범위를 `low = 0`, `high = max(h)`로 설정합니다.
2. 중간값 `mid`를 계산하여 해당 높이에서 나무를 잘랐을 때 나오는 나무 길이의 총합을 구합니다.
3. 잘라낸 나무의 총합이 `m`보다 크면 자를 높이를 더 높여서 잘린 길이를 줄이고, 작으면 자를 높이를 낮춥니다.
4. 최종적으로 `low > high`가 될 때, 자를 수 있는 최적의 높이를 출력합니다.

### 핵심 개념

- **이진 탐색**을 통해 문제를 효율적으로 해결할 수 있습니다. 자를 높이의 범위를 좁혀가면서 필요한 나무의 길이와 맞는 최적의 높이를 찾습니다.
- 이 문제는 탐색 범위가 크기 때문에, 매번 자를 높이를 조정하는 방식보다는 이진 탐색을 사용해야 시간 복잡도를 낮출 수 있습니다.

### 시간 복잡도

이진 탐색의 시간 복잡도는 `O(log(max(h)))`입니다. 각 탐색에서 모든 나무를 확인해야 하므로, 총 시간 복잡도는 `O(n log(max(h)))`가 됩니다.

[<이진탐색 기본구조, 부가 설명>](https://www.notion.so/120900cfb74d808091a5f79cc3fcc6fe?pvs=21)
