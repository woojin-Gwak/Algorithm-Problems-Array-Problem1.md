### 일반적인 이진 탐색 흐름

1. **탐색 범위 설정**:
    - 문제에 따라 탐색할 값의 최소값(`low`)과 최대값(`high`)을 설정합니다.
    - 예시로, Baekjoon 2805번에서는 나무를 자르는 높이를 `low = 0` (최저 절단 높이)에서 `high = 가장 긴 나무의 길이`로 설정합니다.
2. **중간값 계산**:
    - `mid = (low + high) // 2`로 중간값을 계산합니다. 이는 탐색 범위의 중간지점을 의미합니다.
3. **조건에 따라 탐색 범위 줄이기**:
    - 중간값이 조건을 만족하는지 확인한 후, 조건에 따라 `low`와 `high` 값을 조정합니다.
        - **조건을 만족하지 않는다면**: 값이 더 작은 방향으로 탐색 범위를 줄입니다 (`high = mid - 1`).
        - **조건을 만족한다면**: 값이 더 큰 방향으로 탐색 범위를 줄입니다 (`low = mid + 1`).
        - 탐색 범위를 절반으로 줄여나가는 과정을 반복합니다.

### Baekjoon 2805번에서 이진 탐색 적용 방식

Baekjoon 2805번의 경우, **최대한 높은 절단 높이**를 찾아야 합니다. 따라서 절단 높이를 기준으로 이진 탐색을 하는데, 나무를 `mid` 높이에서 자른 후 필요한 나무 양(`m`)보다 많이 잘라냈는지, 적게 잘라냈는지에 따라 범위를 조정합니다:

- **`total < m`**: 필요한 나무 길이보다 덜 잘랐으므로, 나무를 더 많이 자르기 위해 **절단 높이를 낮춤** (`high = mid - 1`).
- **`total >= m`**: 필요한 나무 양을 충분히 잘랐으므로, 절단 높이를 **높여서 더 적게 자를 수 있는지 확인** (`low = mid + 1`).

### 일반적인 이진 탐색 알고리즘 예시

아래는 정렬된 배열에서 특정 값을 찾는 이진 탐색 코드입니다:

```python
python
코드 복사
def binary_search(arr, target):
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = (low + high) // 2

        if arr[mid] == target:
            return mid  # 값을 찾으면 인덱스를 반환
        elif arr[mid] < target:
            low = mid + 1  # 값이 중간값보다 크면 오른쪽 탐색
        else:
            high = mid - 1  # 값이 중간값보다 작으면 왼쪽 탐색

    return -1  # 값을 찾지 못하면 -1 반환

```

이 코드도 마찬가지로 `mid`를 기준으로 탐색 범위를 줄여가며 원하는 값을 찾는 방식입니다.
