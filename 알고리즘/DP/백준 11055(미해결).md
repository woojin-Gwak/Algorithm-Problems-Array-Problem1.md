# [백준 11055: 가장 큰 증가하는 부분 수열의 합](https://www.acmicpc.net/problem/11055)
### 문제 요약

**목표**: 주어진 정수 배열에서 **증가하는 부분 수열의 최대 합**을 찾는 것입니다.

- **부분 수열**: 원래 배열에서 일부 원소를 선택하되 순서를 유지합니다.
- **증가하는 부분 수열**: 선택된 원소들이 서로 증가하는 순서로 나열되어야 함.
- **출력**: 가능한 증가하는 부분 수열의 합 중에서 가장 큰 값을 찾습니다.

### 예시

입력 배열: `[1, 101, 2, 3, 100]`

- 가능한 증가하는 부분 수열:
    - `[1]` (합: 1)
    - `[1, 101]` (합: 102)
    - `[1, 2]` (합: 3)
    - `[1, 2, 3]` (합: 6)
    - `[1, 3]` (합: 4)
    - `[2, 3]` (합: 5)
    - `[1, 2, 100]` (합: 103)
    - `[1, 3, 100]` (합: 104)
    - `[3, 100]` (합: 103)
- **최대 합**: **106** (부분 수열: `[1, 2, 3, 100]`)

### 코드 구현

```python
python
코드 복사
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

# dp 배열을 arr으로 초기화
dp = arr[:]  # dp[i]: arr[i]를 끝으로 하는 증가하는 부분 수열의 최대 합

for i in range(n):
    for j in range(i):
        if arr[j] < arr[i]:  # j번째 원소가 i번째 원소보다 작으면
            dp[i] = max(dp[i], dp[j] + arr[i])  # dp[i] 업데이트

print(max(dp))  # dp 배열에서 최대 합을 출력

```

### 코드 설명

1. **입력 받기**: `n`은 배열의 크기, `arr`은 주어진 정수 배열입니다.
2. **DP 배열 초기화**: `dp[i]`는 `arr[i]`로 초기화하여 각 원소가 자기 자신만으로도 증가하는 부분 수열이 될 수 있도록 합니다.
3. **이중 반복문**:
    - `i`는 현재 원소를 나타내고, `j`는 이전 원소를 나타냅니다.
    - 만약 `arr[j] < arr[i]`이면, `dp[i]`는 `dp[j]`에 `arr[i]`를 더한 값으로 업데이트합니다.
    - `max(dp[i], dp[j] + arr[i])`를 통해 더 큰 값을 선택합니다. 이는 현재의 부분 수열에 `arr[i]`를 추가한 합을 포함하는 것입니다.
4. **최대 합 출력**: 모든 `dp[i]` 값 중에서 최대값을 출력합니다.

### 흔히 겪는 혼란

1. **DP 배열의 초기화**:
    - `dp[i]`를 `arr[i]`로 초기화하는 것이 중요합니다. 만약 초기값을 `0`으로 설정하면 올바른 결과를 얻지 못합니다.
    - 초기값을 `arr[i]`로 설정함으로써, `i` 하나만의 부분 수열로도 시작할 수 있음을 반영합니다.
2. **업데이트 방식**:
    - `dp[i] += arr[j]`와 같은 누적 방식은 잘못된 방식입니다. 이는 각 원소를 여러 번 더할 수 있는 오류를 범하게 됩니다.
    - 항상 `dp[i]`를 **최대값으로 업데이트**해야 하며, 이전의 부분 수열 합을 고려하여 최대합을 반영해야 합니다.
3. **증가하는 부분 수열의 조건**:
    - `arr[j] < arr[i]` 조건을 기억하는 것이 중요합니다. 이는 현재 원소가 이전 원소보다 큰 경우에만 성립하므로, 선택 가능한 증가하는 부분 수열을 생성할 수 있습니다.

### 결론

- 이 문제를 통해 **동적 프로그래밍**의 기초적인 개념과 업데이트 방식을 익힐 수 있습니다.
- 부분 수열의 정의와 업데이트 방식을 정확히 이해하면, 유사한 문제를 해결하는 데 큰 도움이 될 것입니다.
