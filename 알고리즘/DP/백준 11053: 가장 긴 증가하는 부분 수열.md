# [백준 11053: 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
### 문제 설명

- 주어진 수열에서 가장 긴 증가하는 부분 수열(LIS)의 길이를 구하는 문제입니다.
- 증가하는 부분 수열은 원래 수열의 순서를 유지하면서 각 요소가 이전 요소보다 큰 수열입니다.

### 입력 형식

1. **첫 번째 줄**: 수열의 길이 N (1 ≤ N ≤ 1,000)
2. **두 번째 줄**: N개의 정수 a1​,a2​,…,aN​ (1 ≤ ai​ ≤ 1,000,000)

### 출력 형식

- 가장 긴 증가하는 부분 수열의 길이를 출력합니다.

### 예제 입력

```
코드 복사
6
10 20 10 30 20 50

```

### 예제 출력

```
코드 복사
4

```

### 알고리즘 접근 방법

1. **DP 배열 정의하기**:
    - `dp[i]`를 정의합니다. 이는 `i`번째 요소를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이입니다.
2. **DP 초기화**:
    - 모든 `dp[i]`를 1로 초기화합니다. (각 수는 자기 자신만으로 이루어진 부분 수열이므로 길이는 1입니다.)
3. **점화식 적용하기**:
    - 두 개의 중첩된 반복문을 사용하여 각 요소를 확인합니다.
    - 만약 `arr[j] < arr[i]`인 경우, 즉 `j`번째 요소가 `i`번째 요소보다 작으면, `dp[i]`를 업데이트합니다:
    dp[i]=max(dp[i],dp[j]+1)
        
        dp[i]=max⁡(dp[i],dp[j]+1)dp[i] = \max(dp[i], dp[j] + 1)
        
4. **결과 도출하기**:
    - 최종적으로 `max(dp)`를 사용하여 DP 배열에서 가장 큰 값을 찾아 출력합니다.

### 코드 예시

```python
python
코드 복사
N = int(input())
arr = list(map(int, input().split()))
dp = [1] * N  # 각 수를 자기 자신으로 시작하는 증가 수열의 길이

# DP 계산
for i in range(N):
    for j in range(i):
        if arr[j] < arr[i]:  # 증가 조건
            dp[i] = max(dp[i], dp[j] + 1)

# 가장 긴 증가하는 부분 수열의 길이 출력
print(max(dp))

```

### 설명

- **초기화**: `dp` 배열을 모두 1로 초기화하여 각 요소가 자기 자신만으로 이루어진 부분 수열의 길이를 설정합니다.
- **중첩 반복문**: 첫 번째 반복문은 현재 요소 `i`를 선택하고, 두 번째 반복문은 선택된 요소보다 작은 이전 요소 `j`를 탐색하여 증가 조건을 체크합니다.
- **최종 길이 계산**: 모든 요소를 검사한 후, `dp` 배열에서 가장 큰 값을 찾아 가장 긴 증가하는 부분 수열의 길이를 출력합니다.

### 최종 결과

- 주어진 수열 `[10, 20, 10, 30, 20, 50]`에 대해 가장 긴 증가하는 부분 수열은 `[10, 20, 30, 50]`로 길이는 4입니다.
