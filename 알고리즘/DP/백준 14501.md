#[백준 14501번: 퇴사 - DP를 활용한 풀이](https://www.acmicpc.net/problem/14501)
### 문제 요약

- 주어진 상담 일정에 따라 퇴사일 전까지 최대 수익을 얻는 방법을 찾는 문제입니다.

### 접근 방식

1. **DP 배열 구성**:
    - `dp[i]`는 `i`일 전까지 얻을 수 있는 최대 수익을 의미합니다.
    - 이를 통해 특정 날짜 `i`에서 상담을 하지 않는 경우와 하는 경우의 수익을 비교하여 최대값을 갱신할 수 있습니다.
2. **반복문을 통한 최대 수익 계산**:
    - 각 날에 상담이 가능한지 확인하고, 가능한 경우 그 날의 최대 수익을 `dp` 배열에 누적합니다.
    - 일을 하지 않는 경우에는 다음 날까지 현재 수익을 그대로 전달해줍니다.

---

### 코드 설명

```python
python
코드 복사
import sys
input = sys.stdin.readline

n = int(input())
graph = [[] for _ in range(n+1)]
dp = [0] * (n+1)

# 상담 일정 입력 처리
for day in range(n):
    t, p = map(int, input().split())
    if day + t <= n:  # 퇴사일을 넘기지 않는 경우에만 저장
        graph[day].append((t, p))  # (걸리는 일수, 수익)을 저장

# DP 배열 갱신
for i in range(n):
    # 일을 하지 않는 경우 최대 수익을 다음 날로 전달
    dp[i + 1] = max(dp[i + 1], dp[i])

    # 해당 날에 상담을 하는 경우
    for t, p in graph[i]:
        next_day = i + t  # 일을 끝낸 후의 날짜
        if next_day <= n:  # 퇴사일을 넘기지 않는 경우만 고려
            dp[next_day] = max(dp[next_day], dp[i] + p)

# 마지막 날까지 얻을 수 있는 최대 수익 출력
print(dp[n])

```

---

### 코드 흐름 예시

- 예를 들어 `n = 7`일 동안 상담이 주어졌을 때, 각 날의 `t`(상담 기간)와 `p`(수익)를 입력받아 `graph`에 저장하고, `dp` 배열을 통해 각 날의 최대 수익을 누적 갱신합니다.
- `dp[i + 1] = max(dp[i + 1], dp[i])` 부분을 통해 상담을 건너뛰거나, 상담 기간이 끝난 후 얻는 최대 수익을 비교해 누적합니다.

### 최종 결과

- `dp[n]`에 저장된 값이 퇴사일 전까지 얻을 수 있는 최대 수익이 됩니다.

이 방식으로 코드를 실행하면 최적의 결과를 얻을 수 있습니다.
