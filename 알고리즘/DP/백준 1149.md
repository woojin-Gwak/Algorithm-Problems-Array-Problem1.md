# [백준 1149: RGB 거리](https://www.acmicpc.net/problem/1149)
## 문제 개요

**문제 번호**: 1149

**문제 이름**: RGB 거리

**문제 링크**: 백준 1149번 문제

### 문제 설명

주어진 집의 개수 `n`과 각 집의 색칠 비용이 주어질 때, 각 집을 빨강(R), 초록(G), 파랑(B)으로 색칠하는 데 드는 최소 비용을 구하는 문제입니다. 단, 인접한 두 집은 같은 색으로 칠할 수 없습니다.

### 입력

- 첫 번째 줄: 집의 개수 `n` (1 ≤ n ≤ 1000)
- 다음 `n`줄: 각 줄에 빨강, 초록, 파랑의 색칠 비용이 주어집니다. (0 ≤ 비용 ≤ 1,000)

### 출력

- 모든 집을 색칠하는 최소 비용을 출력합니다.

### 문제 접근 방법

1. **동적 계획법(DP)** 사용: 각 집을 색칠할 때 최소 비용을 누적하여 계산합니다.
2. **비용 배열**: 각 집의 색깔별 비용을 `graph` 배열에 저장합니다.
3. **DP 테이블**: `dp[i][j]`를 사용하여 `i`번째 집을 `j`색으로 칠할 때의 최소 비용을 저장합니다.

### 점화식

- `dp[i][0]`: `i`번째 집을 빨강으로 칠할 때의 최소 비용
    - `dp[i][0] = graph[i][0] + min(dp[i-1][1], dp[i-1][2])`
- `dp[i][1]`: `i`번째 집을 초록으로 칠할 때의 최소 비용
    - `dp[i][1] = graph[i][1] + min(dp[i-1][0], dp[i-1][2])`
- `dp[i][2]`: `i`번째 집을 파랑으로 칠할 때의 최소 비용
    - `dp[i][2] = graph[i][2] + min(dp[i-1][0], dp[i-1][1])`

### 초기화

- 첫 번째 집의 비용을 `dp[0]`에 그대로 저장합니다.

### 최종 계산

- 마지막 집의 색칠 비용 중 최소값을 출력합니다.
    - `ans = min(dp[n-1][0], dp[n-1][1], dp[n-1][2])`

### 코드

아래는 전체 코드입니다.

```python
python
코드 복사
import sys
input = sys.stdin.readline

# 집의 개수 입력
n = int(input())
graph = []

# 각 집의 색칠 비용 입력
for _ in range(n):
    r, g, b = map(int, input().split())
    graph.append((r, g, b))

# DP 배열 초기화
dp = [[0]*3 for _ in range(n)]
dp[0][0:3] = graph[0][0:3]  # 첫 번째 집의 비용 초기화

# DP 계산
for i in range(1, n):
    dp[i][0] = graph[i][0] + min(dp[i-1][1], dp[i-1][2])  # 빨강 선택
    dp[i][1] = graph[i][1] + min(dp[i-1][0], dp[i-1][2])  # 초록 선택
    dp[i][2] = graph[i][2] + min(dp[i-1][0], dp[i-1][1])  # 파랑 선택

# 마지막 집의 최소 비용 출력
ans = min(dp[n-1][0], dp[n-1][1], dp[n-1][2])
print(ans)

```

### 요약

- **문제는 DP를 통해 해결**하며, 각 집의 색칠 비용을 누적하여 계산합니다.
- 인접한 집의 색이 같지 않도록 하기 위해 **이전 집의 다른 색 중 최소 비용**을 선택하는 점화식을 활용합니다.
