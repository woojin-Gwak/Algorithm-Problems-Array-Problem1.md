#[백준 9465번: 스티커](https://www.acmicpc.net/problem/9465)
### 문제 설명

- 스티커가 2행 N열로 배치된 모양이 주어집니다.
- 각 스티커에는 점수가 적혀있으며, 인접한 스티커를 뜯지 않는다는 조건하에 스티커를 최대한 많이 뜯어 최댓값을 구하는 문제입니다.

### 접근 방법

이 문제는 **DP**를 사용하여 풀 수 있습니다. 스티커 문제는 연속된 칸의 스티커를 선택하면 안 되는 제한이 있어, 두 행의 위치 관계를 고려한 점화식을 세워야 합니다.

### 점화식 구하기

- `dp[0][i]`와 `dp[1][i]`는 각각 **i열의 스티커를 뜯었을 때 얻을 수 있는 최댓값**을 의미합니다.
- `dp[0][i]`는 **위쪽 행**에서 i번째 스티커를 뜯은 경우, `dp[1][i]`는 **아래쪽 행**에서 i번째 스티커를 뜯은 경우를 나타냅니다.
1. `dp[0][i] = graph[0][i] + max(dp[1][i-1], dp[1][i-2])`
    - `dp[0][i]`: i번째 열의 위쪽 스티커를 선택한 경우 최대 점수
    - 이전 단계에서 아래쪽(i-1)의 스티커를 선택했거나, 두 열 전(i-2)의 아래쪽 스티커를 선택한 경우 중 최댓값을 선택.
2. `dp[1][i] = graph[1][i] + max(dp[0][i-1], dp[0][i-2])`
    - `dp[1][i]`: i번째 열의 아래쪽 스티커를 선택한 경우 최대 점수
    - 이전 단계에서 위쪽(i-1)의 스티커를 선택했거나, 두 열 전(i-2)의 위쪽 스티커를 선택한 경우 중 최댓값을 선택.

### 초기값 설정

- 첫 번째 열의 경우, 바로 해당 스티커만 선택할 수 있기 때문에 초기값으로 설정해줍니다:
    - `dp[0][0] = graph[0][0]`
    - `dp[1][0] = graph[1][0]`
- 두 번째 열부터는 점화식에 따라 값을 구할 수 있습니다.

### 최종 해답

- 마지막 열까지 채운 후, `dp[0][n-1]`과 `dp[1][n-1]` 중에서 최댓값을 선택하여 출력합니다.

### 코드 구현

```python
python
코드 복사
import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    n = int(input())
    graph = [list(map(int, input().split())) for _ in range(2)]

    if n == 1:
        print(max(graph[0][0], graph[1][0]))
        continue

    dp = [[0] * n for _ in range(2)]
    dp[0][0] = graph[0][0]
    dp[1][0] = graph[1][0]
    dp[0][1] = graph[0][1] + dp[1][0]
    dp[1][1] = graph[1][1] + dp[0][0]

    for i in range(2, n):
        dp[0][i] = graph[0][i] + max(dp[1][i-1], dp[1][i-2])
        dp[1][i] = graph[1][i] + max(dp[0][i-1], dp[0][i-2])

    print(max(dp[0][n-1], dp[1][n-1]))

```

### 예제

- 입력:
    
    ```
    코드 복사
    2
    5
    50 10 100 20 40
    30 50 70 10 60
    7
    10 30 10 50 100 20 40
    20 40 30 50 60 20 80
    
    ```
    
- 출력:
    
    ```
    코드 복사
    260
    290
    
    ```
    

### 요약

1. 점화식을 세우고 초기값을 설정하여 DP 테이블을 채웁니다.
2. 모든 열을 탐색 후 최댓값을 선택하여 출력합니다.
