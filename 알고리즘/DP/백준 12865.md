# [백준 12865번: 평범한 배낭 문제 정리](https://www.acmicpc.net/problem/12865)
### 문제 설명

- 물건의 수 n과 배낭의 최대 무게 k가 주어집니다.
- 각 물건은 무게 w와 가치 v를 가집니다.
- 배낭에 넣을 수 있는 물건을 선택하여 최대한 높은 가치를 가지도록 하는 문제입니다.

### 접근 방식

- **DP 배열**을 사용해 최대 가치를 계산합니다.
- **점화식**을 세워, 무게 제한 내에서 물건을 넣거나 안 넣을 때 최대 가치를 비교하며 최적의 해를 구합니다.

### 코드 흐름 및 순서도

```python
python
코드 복사
import sys
input = sys.stdin.readline

# 입력 처리
n, k = map(int, input().split())  # 물건 수 n, 최대 무게 k
items = [tuple(map(int, input().split())) for _ in range(n)]

# DP 테이블 생성
dp = [0] * (k + 1)

# DP 점화식을 통해 최대 가치 계산
for w, v in items:
    # 큰 무게부터 작은 무게로 거꾸로 업데이트
    for j in range(k, w - 1, -1):
        dp[j] = max(dp[j], dp[j - w] + v)

print(dp[k])  # 최대 가치 출력

```

### 예시와 흐름

예시 입력:

```makefile
makefile
코드 복사
n = 4, k = 7
items = [(6, 13), (4, 8), (3, 6), (5, 12)]

```

### 과정 설명

1. **초기화 및 입력**
    - `dp` 배열을 길이 k+1로 초기화하여 `dp[0]`부터 `dp[7]`까지 모두 0으로 설정합니다.
        
        k+1k+1
        
    - `items` 리스트에 각 물건의 (무게, 가치) 쌍을 저장합니다.
2. **아이템별 반복문 (각 무게의 경우)**
    - 아이템을 하나씩 반복하며, 무게 제한을 고려해 `dp` 테이블을 갱신합니다.
    - 각 무게마다 현재 아이템을 선택하거나 선택하지 않을 때 최대 가치를 비교합니다.
3. **큰 무게부터 작은 무게로 갱신하는 이유**
    - `dp` 배열을 뒤에서부터 갱신하는 이유는, 중복 계산을 방지하고 이미 선택한 물건의 무게를 더하지 않기 위함입니다.

### 점화식 설명

- `dp[j] = max(dp[j], dp[j - w] + v)`각 무게 `j`에서 현재 아이템을 선택한 경우와 선택하지 않은 경우 중 큰 값을 선택합니다.

### 최종 DP 배열

최종적으로 `dp` 배열에는 각 무게에서 얻을 수 있는 최대 가치가 저장되며, `dp[k]`가 최대 가치가 됩니다.

### 출력

- 예시 입력에서 `dp[7] = 14`가 되어 최종적으로 `14`가 출력됩니다.

### 요약 정리

이 문제는 0/1 배낭 문제로 **DP 배열을 사용해 가치의 최댓값을 누적**하는 점화식을 통해 해결합니다.
