# 동적 계획법 (Dynamic Programming)

동적 계획법(DP)은 최적화 문제를 해결하기 위해 큰 문제를 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 중복 계산을 피하는 알고리즘 기법입니다.

## 주요 특징
- **문제를 작은 하위 문제로 분할**하여 해결합니다.
- **결과를 저장**하여 중복 계산을 방지합니다. (메모이제이션, 테이블 이용)
- **최적화 문제**에서 유용하게 사용됩니다.

## 알고리즘 기법
- **배열을 이용한 DP**: 결과를 저장하는 배열을 사용하여 문제를 해결합니다.
- **메모이제이션**: 계산된 값을 저장하고 필요할 때만 재사용합니다.
- **바텀업 방식**: 작은 문제부터 풀어가며 결과를 쌓아갑니다.
- **탑다운 방식**: 재귀적으로 문제를 풀되, 계산된 값을 메모이제이션하여 중복 계산을 줄입니다.

## 예시 문제
- **백준 1003번 피보나치 함수**: 가장 기본적인 DP 문제로, 피보나치 수를 계산하는 문제입니다.
- **백준 12865번 평범한 배낭**: 배낭 문제로, 제한된 용량 내에서 물건을 선택하는 문제입니다.
# 동적 계획법 (Dynamic Programming) 개념 정리

## 기본 개념

### 1. 문제 분할
- 큰 문제를 작은 하위 문제로 분할하여 해결합니다.
- 하위 문제들이 서로 독립적이지 않고 중복되는 부분 문제들이 존재해야 DP로 풀 수 있습니다.

### 2. 상태 정의
- 문제에서 상태가 무엇을 의미하는지를 정의합니다.
- 예시: `dp[i]`는 i번째 문제에서의 최적 해를 의미할 수 있습니다.

### 3. 점화식
- 이전 단계에서의 계산된 값을 활용해 현재 문제를 해결하는 관계를 정의합니다.
- 예시: 피보나치 수열에서는 `dp[i] = dp[i-1] + dp[i-2]`가 점화식입니다.

### 4. 기저 사례
- 가장 작은 문제를 해결할 수 있는 기저 사례를 정의해야 합니다.
- 예시: `dp[0] = 0`, `dp[1] = 1` 등 초기값을 설정합니다.

### 5. 테이블을 사용하여 중복 계산 피하기
- 계산된 값을 배열 또는 테이블에 저장하여 중복 계산을 피하고, 문제를 해결합니다.

## 예시 문제

### **1. 피보나치 수열**
피보나치 수열을 구하는 문제로, 동적 계획법을 사용하여 O(N)의 시간 복잡도로 해결할 수 있습니다.

#### 점화식:
- `dp[i] = dp[i-1] + dp[i-2]`

#### 기저 사례:
- `dp[0] = 0`, `dp[1] = 1`

#### 코드:
```python
def fibonacci(n):
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
