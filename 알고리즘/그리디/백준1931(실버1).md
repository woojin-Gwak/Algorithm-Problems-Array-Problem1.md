# [Baekjoon Problem 1931: 회의실 배정](https://www.acmicpc.net/problem/1931)

### 문제 설명

주어진 회의의 시작 시간과 종료 시간이 있을 때, 최대한 많은 회의를 동시에 배정할 수 있도록 하려면 어떻게 해야 할까요? 각 회의는 시작 시간과 종료 시간이 주어지고, 회의가 끝난 후에 새로운 회의를 시작할 수 있습니다.

### 입력

- 첫 번째 줄에 회의의 수 `n`이 주어집니다.
- 다음 `n`개의 줄에 각 회의의 시작 시간과 종료 시간이 주어집니다.

### 출력

- 최대 회의의 개수를 출력합니다.

### 접근 방법

1. **그리디 알고리즘**: 종료 시간이 가장 빠른 회의부터 선택하여 가능한 한 많은 회의를 배정하는 방식입니다. 종료 시간이 같으면 시작 시간을 기준으로 정렬합니다.
2. **정렬**: 먼저 종료 시간으로 정렬하고, 종료 시간이 같은 경우에는 시작 시간으로 정렬합니다.
3. **카운팅**: 각 회의를 순회하면서 현재 회의의 시작 시간이 이전 회의의 종료 시간보다 크거나 같으면 회의를 배정합니다.

### 코드

```python
python
코드 복사
import sys
input = sys.stdin.readline

n = int(input())
t = [tuple(map(int, input().split())) for _ in range(n)]  # 각 회의의 시작과 종료 시간 입력

# 종료 시간 기준으로 정렬, 종료 시간이 같으면 시작 시간 기준으로 정렬
t.sort(key=lambda x: (x[1], x[0]))

end_time, cnt = 0, 0  # 종료 시간과 회의 개수를 초기화

for start, end in t:
    if start >= end_time:  # 현재 회의의 시작 시간이 이전 회의의 종료 시간보다 크거나 같으면
        cnt += 1           # 회의 개수 증가
        end_time = end     # 종료 시간 업데이트

print(cnt)  # 최대 회의 개수 출력

```

### 질문 및 답변 요약

1. **`map` 객체와 튜플**: `t = [(map(int, input().split())) for _ in range(n)]`로 작성할 경우 `map` 객체가 리스트에 저장되어 에러가 발생할 수 있습니다. 올바른 방법은 `t = [tuple(map(int, input().split())) for _ in range(n)]`로 `map`을 튜플로 변환해야 합니다.
2. **리스트 컴프리헨션 vs for 루프**:
    - 리스트 컴프리헨션은 코드가 간결하지만, `map` 객체의 사용에 주의해야 합니다.
    - for 루프는 더 명시적이어서 이해하기 쉽고, 성능 차이는 미세합니다.
3. **변수 초기화**: `end_time, cnt = 0, 0`은 각각 회의의 종료 시간을 저장하고, 배정된 회의의 수를 카운팅하기 위한 변수 초기화입니다.

### 결론

이 문제는 그리디 알고리즘을 이용하여 효율적으로 해결할 수 있으며, 회의의 시작 및 종료 시간을 정렬한 후, 조건을 체크하여 최대한 많은 회의를 배정하는 방식을 사용합니다.
