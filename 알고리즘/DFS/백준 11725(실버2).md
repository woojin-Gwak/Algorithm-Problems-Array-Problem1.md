# [백준 11725: 트리의 부모 찾기](https://www.acmicpc.net/problem/11725)
백준 11725번 문제는 **각 노드의 부모 노드를 찾는 문제**입니다. 주어진 트리에서 노드 1을 루트로 설정하고, **각 노드의 부모가 되는 노드를 찾아 출력**하는 것이 목표입니다.

### 문제에서 출력해야 할 것

트리의 각 노드에 대해 **1번 노드를 제**

**외한 나머지 노드들의 부모 노드**를 출력해야 합니다. 예를 들어, 입력이 다음과 같다면:

```
코드 복사
7
1 6
6 3
3 5
4 1
2 4
4 7

```

출력은 각 노드의 부모 노드를 **2번 노드부터 순서대로 출력**하는 형태가 됩니다.

### 문제점 및 수정 사항

작성하신 코드에는 몇 가지 수정할 부분이 있습니다.

1. **`visited[v]` 대신 `visited[i]`를 체크**해야 합니다. 현재 방문한 노드가 아니라, **방문할 노드가 이미 방문되었는지 확인**하는 것이 필요합니다.
2. **부모 노드를 저장할 배열**을 추가해야 합니다. 방문한 노드에 대해 부모 노드를 기록하여 이후에 출력할 수 있도록 `parent` 배열을 사용합니다.
3. **`dfs` 함수 호출 오류**: 마지막 줄의 `dsf(2)`는 `dfs(2)`로 수정되어야 합니다. 문제에서 요구하는 대로 루트 노드를 1로 설정해야 하므로 `dfs(1)`을 호출해야 합니다.

### 수정된 코드

다음은 수정된 코드입니다.

```python
python
코드 복사
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

n = int(input())
tree = [[] for _ in range(n + 1)]
visited = [False] * (n + 1)
parent = [0] * (n + 1)  # 부모 노드를 저장할 배열

# 트리 구조 입력 받기
for _ in range(n - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)

# DFS 함수 정의
def dfs(v):
    visited[v] = True
    for i in tree[v]:
        if not visited[i]:  # 방문하지 않은 노드에 대해
            parent[i] = v  # 부모 노드 저장
            dfs(i)  # 재귀 호출

# 루트 노드(1번 노드)에서 DFS 시작
dfs(1)

# 2번 노드부터 부모 노드 출력
for i in range(2, n + 1):
    print(parent[i])

```

### 코드 설명

1. **부모 노드 저장**: `parent` 배열에 각 노드의 부모 노드를 저장합니다.
2. **DFS를 통한 트리 순회**: `dfs` 함수는 노드를 방문하면서, 아직 방문하지 않은 연결된 노드에 대해 부모 노드를 기록합니다.
3. **출력 부분**: 루트 노드인 1번 노드를 제외하고 2번 노드부터 `parent[i]` 값을 출력합니다.

### 출력 예시

입력이 다음과 같다면:

```
코드 복사
7
1 6
6 3
3 5
4 1
2 4
4 7

```

출력은 다음과 같이 나옵니다:

```
코드 복사
4
6
1
3
1
4

```

이제 이 코드는 백준 11725번 문제의 요구 사항에 맞게 각 노드의 부모 노드를 정확히 출력할 것입니다.

## 코드 흐름 과정

### 예시 입력을 사용해 DFS가 트리에서 부모 노드를 찾는 과정을 순서대로 설명해 볼게요.

### 예시 입력

노드 수 `n = 7`이고, 각 간선 정보는 다음과 같습니다.

```
코드 복사
7
1 6
6 3
3 5
4 1
2 4
4 7

```

이 간선 정보로부터 트리 구조를 만들면 아래와 같이 연결됩니다:

```
코드 복사
1 - 6
6 - 3
3 - 5
4 - 1
2 - 4
4 - 7

```

이를 트리 구조로 정리하면 다음과 같이 됩니다. `1`을 루트 노드로 설정합니다.

```markdown
markdown
코드 복사
        1
      /   \
     6     4
      |   / \
      3  2   7
      |
      5

```

### DFS 탐색 및 부모 노드 찾기 흐름

이제 `dfs(1)` 호출을 통해 DFS로 트리를 탐색하면서 각 노드의 부모를 찾는 과정을 순서대로 보겠습니다.

1. **`dfs(1)` 호출**:
    - 현재 노드 `1`을 방문하고, `visited[1] = True`로 설정.
    - `1`에 연결된 노드 `6`과 `4`를 확인.
2. **`dfs(6)` 호출**:
    - 노드 `6`을 방문하고, `visited[6] = True`로 설정.
    - `6`의 부모로 `1`을 저장 (`parent[6] = 1`).
    - `6`에 연결된 노드 `1`(이미 방문됨)과 `3`을 확인.
3. **`dfs(3)` 호출**:
    - 노드 `3`을 방문하고, `visited[3] = True`로 설정.
    - `3`의 부모로 `6`을 저장 (`parent[3] = 6`).
    - `3`에 연결된 노드 `6`(이미 방문됨)과 `5`를 확인.
4. **`dfs(5)` 호출**:
    - 노드 `5`를 방문하고, `visited[5] = True`로 설정.
    - `5`의 부모로 `3`을 저장 (`parent[5] = 3`).
    - `5`에 연결된 노드 `3`(이미 방문됨)만 확인되므로, `dfs(5)` 종료.
5. **`dfs(3)`로 돌아옴**:
    - `dfs(5)` 호출이 종료되면 `dfs(3)`도 종료됩니다.
6. **`dfs(6)`로 돌아옴**:
    - `dfs(3)` 호출이 종료되면 `dfs(6)`도 종료됩니다.
7. **`dfs(1)`로 돌아옴**:
    - `dfs(6)` 호출이 종료되면 `dfs(1)`로 돌아와서, `4`를 확인합니다.
8. **`dfs(4)` 호출**:
    - 노드 `4`를 방문하고, `visited[4] = True`로 설정.
    - `4`의 부모로 `1`을 저장 (`parent[4] = 1`).
    - `4`에 연결된 노드 `1`(이미 방문됨), `2`, `7`을 확인.
9. **`dfs(2)` 호출**:
    - 노드 `2`를 방문하고, `visited[2] = True`로 설정.
    - `2`의 부모로 `4`를 저장 (`parent[2] = 4`).
    - `2`에 연결된 노드 `4`(이미 방문됨)만 확인되므로, `dfs(2)` 종료.
10. **`dfs(4)`로 돌아옴**:
    - `dfs(2)` 호출이 종료되면 `dfs(4)`로 돌아와서, `7`을 확인합니다.
11. **`dfs(7)` 호출**:
    - 노드 `7`을 방문하고, `visited[7] = True`로 설정.
    - `7`의 부모로 `4`를 저장 (`parent[7] = 4`).
    - `7`에 연결된 노드 `4`(이미 방문됨)만 확인되므로, `dfs(7)` 종료.
12. **모든 DFS 탐색 종료**:
    - `dfs(4)`, `dfs(1)`이 모두 종료되며 DFS 탐색이 완료됩니다.

### 최종 부모 노드 출력

탐색이 완료되면, 2번 노드부터 `n`번 노드까지 각 노드의 부모 노드를 출력합니다. `parent` 배열의 값은 다음과 같습니다.

```css
css
코드 복사
parent = [0, 0, 4, 6, 1, 3, 1, 4]

```

출력 결과는 2번 노드부터 시작하여 다음과 같이 됩니다:

```
코드 복사
4
6
1
3
1
4

```

따라서 최종 출력은 아래와 같이 나옵니다.

```
코드 복사
4
6
1
3
1
4

```

이렇게 출력하면 문제에서 요구한 대로 각 노드의 부모를 정확히 구할 수 있습니다.
