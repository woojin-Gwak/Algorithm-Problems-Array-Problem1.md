# [백준 2606번 바이러스](https://www.acmicpc.net/problem/2606)

1번 컴퓨터가 바이러스에 감염되었을 때, 네트워크를 통해 몇 대의 컴퓨터가 감염되는지를 DFS(깊이 우선 탐색)를 이용해 계산하는 문제입니다.

### 코드 분석:

```python
python
코드 복사
import sys
input = sys.stdin.readline  # 빠른 입력을 위한 sys.stdin.readline 사용

# 컴퓨터의 수 입력
n = int(input())

# 연결된 네트워크 쌍의 수 입력
m = int(input())

# DFS 함수 정의
def dfs(c):
    global ans  # 전역 변수 ans를 사용해 감염된 컴퓨터 수를 셈
    ans += 1  # 현재 컴퓨터 감염 처리
    visit[c] = 1  # 현재 컴퓨터 방문 표시
    for i in graph[c]:  # 현재 컴퓨터와 연결된 컴퓨터 탐색
        if not visit[i]:  # 방문하지 않은 컴퓨터가 있으면
            dfs(i)  # 그 컴퓨터로 DFS 재귀 호출

# 그래프 초기화 (1번부터 n번까지)
graph = [[] for _ in range(n+1)]

# 네트워크 연결 정보 입력
for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# 감염된 컴퓨터 수와 방문 리스트 초기화
ans = 0
visit = [0] * (n+1)

# 1번 컴퓨터에서 DFS 탐색 시작
dfs(1)

# 1번 컴퓨터를 제외한 감염된 컴퓨터 수 출력
print(ans - 1)
```

### 주요 설명:

1. **입력 받기**:
    - `sys.stdin.readline`을 사용해 빠르게 입력을 받습니다.
    - `n`은 컴퓨터의 수, `m`은 네트워크 연결된 쌍의 수를 의미합니다.
2. **DFS 함수**:
    - `dfs` 함수는 재귀적으로 컴퓨터 간의 연결을 탐색합니다.
    - `visit` 리스트를 사용해 방문한 컴퓨터를 기록하고, `ans` 변수를 통해 감염된 컴퓨터의 수를 셉니다.
3. **그래프 구성**:
    - `graph` 리스트는 인접 리스트 형태로 네트워크 연결 정보를 저장합니다.
    - 연결된 두 컴퓨터의 번호를 받아 양방향 연결을 만듭니다.
4. **방문 처리 및 출력**:
    - 1번 컴퓨터부터 DFS를 실행하며, 모든 연결된 컴퓨터들을 탐색합니다.
    - 1번 컴퓨터는 제외하고 감염된 컴퓨터의 수를 출력합니다.

### 사용한 주요 개념:

- **DFS(깊이 우선 탐색)**: 현재 노드와 연결된 모든 노드를 끝까지 탐색하는 방식.
- **인접 리스트**: 연결 정보를 효율적으로 저장하기 위해 리스트를 사용.

### DFS와 BFS 비교:

- **BFS**는 너비 우선 탐색으로, 가까운 노드부터 차례대로 탐색합니다.
- **DFS**는 깊이 우선 탐색으로, 하나의 경로를 끝까지 탐색한 후 다른 경로를 탐색합니다.

### DFS(깊이 우선 탐색) 설명 및 활용 팁

### DFS 기본 개념:

- **재귀(Recursion)**: DFS는 재귀적으로 호출되며, 하나의 경로를 끝까지 탐색한 후 다른 경로를 탐색합니다.
- **스택(Stack)**: DFS는 스택을 사용하여 탐색합니다. 재귀 호출 자체가 스택 구조로 동작합니다.

### DFS의 동작 흐름:

1. 현재 노드를 **방문 처리**하고,
2. 연결된 노드 중 방문하지 않은 노드를 재귀적으로 탐색합니다.
3. 더 이상 방문할 노드가 없으면, 이전 단계로 돌아가 다른 경로를 탐색합니다.

### DFS의 장점과 활용:

1. **경로 찾기**: 그래프나 트리에서 특정 경로를 찾는 문제에 유용합니다. 미로 탐색 문제처럼 출발점에서 도착점까지의 경로를 찾을 때 사용됩니다.
2. **연결된 컴포넌트 탐색**: 서로 연결된 노드를 찾는 문제, 예를 들어 네트워크에서 연결된 컴퓨터들을 탐색할 때 유용합니다.
3. **백트래킹 문제 해결**: DFS는 백트래킹 문제를 해결할 때 사용됩니다. 조건을 만족하지 않는 경로를 포기하고 다른 경로를 탐색하는 방식입니다.

### DFS 기본 구조 (예시 코드):

```python
python
코드 복사
def dfs(v):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(i)

```

### DFS를 잘 활용하기 위한 팁:

1. **방문 처리 필수**: 방문한 노드를 다시 방문하지 않도록 체크하는 것이 중요합니다.
2. **재귀 깊이 제한**: 파이썬은 재귀 깊이에 제한이 있으므로, 필요한 경우 `sys.setrecursionlimit()`으로 재귀 깊이 제한을 조절할 수 있습니다.
3. **비재귀 DFS**: 스택을 사용하여 DFS를 비재귀 방식으로 구현할 수도 있습니다.

### DFS 비재귀 구현 (스택 사용):

```python
python
코드 복사
def dfs_iterative(start):
    stack = [start]
    visited[start] = True

    while stack:
        v = stack.pop()
        print(v, end=' ')

        for i in graph[v]:
            if not visited[i]:
                stack.append(i)
                visited[i] = True

```

### 결론:

- DFS는 깊이 있는 탐색이 필요한 문제에 적합합니다.
- 방문 처리를 항상 신경 쓰고, 재귀의 깊이에 주의하며 문제를 해결합니다.

[백준1012번: 유기농 배추](https://www.notion.so/1012-11a900cfb74d80268602e8488df02cf3?pvs=21)

[백준 11725: 트리의 부모 찾기](https://www.notion.so/11725-12f900cfb74d8039ad50e51a3900a0f4?pvs=21)
