# [백준1012번: 유기농 배추](https://www.acmicpc.net/problem/1012)
**문제 요약**:

농부는 유기농 배추를 재배하는 농장에 대해 이야기하고 있습니다. 이 농장은 격자 형태로 표현되며, 배추가 심어진 곳은 `1`, 심어지지 않은 곳은 `0`으로 표시됩니다. 상하좌우로 연결된 `1`들은 하나의 배추 군집으로 간주됩니다. 이 문제에서는 여러 테스트 케이스에 대해 배추 군집의 수를 계산해야 합니다.

---

### 입력 형식

첫 번째 줄: 테스트 케이스의 수 T (1 ≤ T ≤ 50)

### 출력 형식

- 각 테스트 케이스마다 연결된 배추 군집의 수를 출력합니다.

---

### 문제 해결 접근 방법

이 문제를 해결하기 위해서는 다음과 같은 단계가 필요합니다:

1. **입력 데이터 처리**: 입력을 받아 배추가 심어진 위치를 기록합니다.
2. **그래프 탐색**: DFS(깊이 우선 탐색) 또는 BFS(너비 우선 탐색) 알고리즘을 사용하여 연결된 배추 군집을 찾습니다.
3. **군집 개수 세기**: 탐색을 통해 군집의 개수를 세어 출력합니다.

---

### 코드 설명

```python
python
코드 복사
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**6)  # 재귀 깊이 설정

t = int(input())  # 테스트 케이스 수

# 이동 방향 정의 (아래, 위, 오른쪽, 왼쪽)
dirR = [1, -1, 0, 0]  # 행(세로) 이동
dirC = [0, 0, 1, -1]  # 열(가로) 이동

def dfs(b, a):
    visit[b][a] = 1  # 현재 위치를 방문 처리
    for index in range(4):  # 네 방향 탐색
        new_b = b + dirR[index]  # 새로운 행 위치
        new_a = a + dirC[index]  # 새로운 열 위치
        if graph[new_b][new_a] == 1 and not visit[new_b][new_a]:  # 연결된 배추가 있는지 확인
            dfs(new_b, new_a)  # DFS 호출

for _ in range(t):
    m, n, k = map(int, input().split())  # 가로, 세로, 배추 개수 입력
    # 그래프와 방문 배열 초기화 (1부터 시작)
    graph = [[0 for _ in range(m + 2)] for _ in range(n + 2)]  # 그래프 초기화
    visit = [[0 for _ in range(m + 2)] for _ in range(n + 2)]  # 방문 배열 초기화

    for _ in range(k):
        a, b = map(int, input().split())  # 배추 위치 입력
        graph[b + 1][a + 1] = 1  # 그래프에 배추 위치 표시

    ans = 0  # 군집 수 초기화
    for i in range(1, n + 1):  # 행 탐색
        for j in range(1, m + 1):  # 열 탐색
            if graph[i][j] == 1 and not visit[i][j]:  # 새로운 군집 발견
                dfs(i, j)  # DFS 호출
                ans += 1  # 군집 수 증가

    print(ans)  # 각 테스트 케이스 결과 출력

```

### 주요 포인트

1. **재귀 깊이 설정**: DFS를 사용할 때는 재귀 호출이 깊어질 수 있으므로 `sys.setrecursionlimit(10**6)`로 재귀 깊이를 늘립니다.
2. **DFS 함수**:
    - 현재 위치를 방문 처리하고,
    - 상하좌우로 인접한 배추가 있는지 확인합니다.
    - 인접한 배추가 있으면 DFS를 재귀적으로 호출하여 연결된 모든 배추를 방문합니다.
3. **그래프 및 방문 배열 초기화**:
    - 그래프 배열은 `(n + 2) x (m + 2)` 크기로 만들고, 1부터 시작하는 인덱스를 사용하여 경계 체크를 피합니다.
    - 방문 배열도 같은 방식으로 초기화합니다.
4. **군집 세기**:
    - 이중 반복문을 사용하여 그래프의 모든 위치를 탐색합니다.
    - `1`인 위치에서 방문하지 않은 경우 DFS를 호출하고, 군집 수를 증가시킵니다.
