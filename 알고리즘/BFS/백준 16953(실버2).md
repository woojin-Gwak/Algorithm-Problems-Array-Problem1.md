# [백준 16953번: A를 B로 만들기](https://www.acmicpc.net/problem/16953)
### 문제 설명

- 정수 A를 시작으로, B로 변환하는 최소한의 연산 횟수를 구하는 문제입니다.
- 사용할 수 있는 연산은 두 가지입니다:
    1. 현재 수가 짝수라면 2로 나누기
    2. 현재 수의 끝자리가 1이면 끝자리의 1을 제거하기

---

### 접근 방법

1. **역방향 접근**:
    - 목표 숫자 B에서 시작하여 A로 돌아가는 방향으로 탐색합니다.
    - 연산의 조건에 따라 B에서 A로 가는 최적의 방법을 찾습니다.
2. **BFS (너비 우선 탐색)**:
    - 최소 연산 횟수를 구하는 문제이므로 최단 경로 탐색에 유리한 BFS를 사용하여 해결합니다.

---

### 풀이 코드

```python
python
코드 복사
import sys
from collections import deque

input = sys.stdin.readline

a, b = map(int, input().split())

def bfs(start, cnt):
    queue = deque([(start, cnt)])

    while queue:
        now, cnt = queue.popleft()

        # 목표 값 A에 도달했을 때 연산 횟수 반환
        if now == a:
            return cnt

        # 현재 값이 A보다 큰 경우만 연산 수행
        if now > a:
            # 현재 값이 짝수이면 2로 나누기
            if now % 2 == 0:
                queue.append((now // 2, cnt + 1))
            # 현재 값의 끝자리가 1이면 마지막 1 제거
            elif now % 10 == 1:
                queue.append((now // 10, cnt + 1))

    # 변환이 불가능한 경우 -1 반환
    return -1

# BFS 실행 후 결과 출력
print(bfs(b, 1))

```

---

### 동작 과정

1. **큐 초기화**: `(현재 값, 연산 횟수)` 형태의 튜플을 큐에 넣고 시작합니다.
2. **목표값 체크**: 현재 값이 목표값 `a`와 같으면 연산 횟수 `cnt`를 반환하고 종료합니다.
3. **연산 수행**:
    - 현재 값이 `a`보다 크다면 두 가지 연산을 시도합니다.
        1. 짝수일 때 2로 나누기
        2. 끝자리가 1일 때 끝의 1 제거하기
4. **결과**:
    - 큐를 모두 탐색하고도 `a`에 도달하지 못하면 `1`을 반환하여 변환이 불가능함을 나타냅니다.

---

### 시간복잡도 분석

- 각 숫자에 대해 최대 두 가지 연산이 가능하므로 탐색의 경우의 수는 제한적입니다.
- **BFS**를 사용하여 매 단계에서 최단 경로를 탐색하므로 시간 효율적입니다.

---


### 예시 입력

```
코드 복사
2 162

```

### 출력

```
코드 복사
5

```

### 설명

162 → 81 → 8 → 4 → 2
