# [백준 15663번: 중복 순열 제거 및 백트래킹](https://www.acmicpc.net/problem/15663)
### 문제 요약

- **목적**: 주어진 배열에서 중복을 제거한 길이 `m`의 모든 순열을 구합니다.
- **중복 제거 조건**: 배열에 중복된 값이 포함될 수 있으며, 결과 순열에서 중복된 순열이 나타나면 안 됩니다.

### 코드 설명

1. **초기 설정**
    
    ```python
    python
    코드 복사
    import sys
    input = sys.stdin.readline
    
    n, m = map(int, input().split())
    arr = list(map(int, input().split()))
    arr.sort()  # 배열을 오름차순으로 정렬하여 중복 관리가 쉬워짐
    result = []  # 현재까지 선택한 순열을 저장
    visited = [False] * n  # 배열의 각 요소가 사용되었는지 체크
    
    ```
    
2. **백트래킹 함수** `btr`
    - 이 함수는 중복되지 않은 순열을 구성하여 길이가 `m`이 되면 출력하고, 아니라면 순차적으로 값을 추가합니다.
    
    ```python
    python
    코드 복사
    def btr():
        if len(result) == m:
            print(' '.join(map(str, result)))  # 결과 출력
            return
    
        prev = -1  # 이전에 사용한 숫자를 저장하여 중복 제거
    
        for i in range(n):
            if not visited[i] and arr[i] != prev:  # 중복되지 않고 방문되지 않은 숫자만 선택
                visited[i] = True
                result.append(arr[i])
                btr()  # 재귀적으로 다음 숫자 선택
                result.pop()  # 돌아와서 마지막 숫자 제거
                visited[i] = False  # 사용했던 숫자 복구
                prev = arr[i]  # 현재 숫자를 prev로 저장
    
    ```
    
3. **중복 제거 로직**
    - `prev` 변수를 이용해 바로 직전 단계에서 선택한 숫자를 기록함으로써, 이미 확인한 숫자가 중복 선택되지 않도록 합니다.
    - `if not visited[i] and arr[i] != prev`: **조건**에서 `visited[i]`와 `prev`를 통해 한 번 사용한 숫자는 다시 선택하지 않음.
4. **코드 실행 및 결과**
    
    ```python
    python
    코드 복사
    btr()
    
    ```
    

### 예제

입력이 `4 2`와 `1 1 2 2`일 경우:

- 출력 결과:
    
    ```
    코드 복사
    1 1
    1 2
    2 1
    2 2
    
    ```
    

### 정리 포인트

- 중복된 수열을 방지하기 위해 `arr`를 정렬한 후 `prev` 변수를 활용해 중복 요소를 필터링했습니다.
- `visited` 배열을 사용하여 이미 선택한 원소를 다시 선택하지 않도록 했습니다.

### 처리 과정 상세

주어진 코드가 `4 2`와 `1 1 2 2`를 입력으로 받을 때 중복 없는 순열을 생성하는 과정을 단계별로 보기 좋게 정리해볼게요.

### 문제 조건

- 입력: `n=4`, `m=2`, `arr=[1, 1, 2, 2]`
- 목표: 배열에서 중복되지 않는 모든 길이 `m=2`의 순열을 출력
- 정렬된 `arr`에서 순서를 유지하며 중복 순열 방지

---

### 코드의 동작 과정

### 초기화

- `arr.sort()` → `[1, 1, 2, 2]`
- `visited = [False, False, False, False]`

### 백트래킹 과정 요약

| 단계 | 현재 `depth` | `result` | `visited` | 출력 여부 | 설명 |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | `[]` | `[F, F, F, F]` | - | `depth`가 0일 때 시작 |
| 2 | 1 | `[1]` | `[T, F, F, F]` | - | 첫 번째 요소 `1` 선택 |
| 3 | 2 | `[1, 1]` | `[T, T, F, F]` | `1 1` | 두 번째 요소 `1` 선택 및 출력 |
| 4 | 1 | `[1]` | `[T, F, F, F]` | - | 백트래킹: `1` 제거 |
| 5 | 2 | `[1, 2]` | `[T, F, T, F]` | `1 2` | 세 번째 요소 `2` 선택 및 출력 |
| 6 | 1 | `[1]` | `[T, F, F, F]` | - | 백트래킹: `2` 제거 |
| 7 | 0 | `[]` | `[F, F, F, F]` | - | 백트래킹: `1` 제거 |
| 8 | 1 | `[2]` | `[F, F, T, F]` | - | 세 번째 요소 `2` 선택 |
| 9 | 2 | `[2, 1]` | `[T, F, T, F]` | `2 1` | 첫 번째 요소 `1` 선택 및 출력 |
| 10 | 1 | `[2]` | `[F, F, T, F]` | - | 백트래킹: `1` 제거 |
| 11 | 2 | `[2, 2]` | `[F, F, T, T]` | `2 2` | 네 번째 요소 `2` 선택 및 출력 |

---

### 동작 과정 상세

### Step 1. 첫 번째 숫자 선택 (`depth = 0`)

1. `i = 0`: `arr[0] = 1` 선택 → `result = [1]`, `visited = [T, F, F, F]`
    - `prev = 1`으로 설정
2. 재귀 호출 `btr(depth = 1)`

### Step 2. 두 번째 숫자 선택 (`depth = 1`)

1. `i = 1`: `arr[1] = 1` 선택 (중복 방지 통과) → `result = [1, 1]`, `visited = [T, T, F, F]`
    - 순열 완성, 출력: `1 1`
    - 백트래킹 후 `result = [1]`, `visited = [T, F, F, F]`
2. `i = 2`: `arr[2] = 2` 선택 → `result = [1, 2]`, `visited = [T, F, T, F]`
    - 순열 완성, 출력: `1 2`
    - 백트래킹 후 `result = [1]`, `visited = [T, F, F, F]`
3. `i = 3`: `arr[3] = 2` 선택 불가 (`prev = 2`로 중복 방지)

### Step 3. 백트래킹 (`depth = 0`)

- `result = []`, `visited = [F, F, F, F]`

### Step 4. 새 순열 시작 (`depth = 0`)

1. `i = 2`: `arr[2] = 2` 선택 → `result = [2]`, `visited = [F, F, T, F]`
2. 재귀 호출 `btr(depth = 1)`

### Step 5. 순열 완성 및 출력 (`depth = 1`)

1. `i = 0`: `arr[0] = 1` 선택 → `result = [2, 1]`, `visited = [T, F, T, F]`
    - 순열 완성, 출력: `2 1`
    - 백트래킹 후 `result = [2]`, `visited = [F, F, T, F]`
2. `i = 3`: `arr[3] = 2` 선택 → `result = [2, 2]`, `visited = [F, F, T, T]`
    - 순열 완성, 출력: `2 2`
    - 백트래킹 후 `result = [2]`, `visited = [F, F, T, F]`

이 과정을 통해 중복 없이 `1 1`, `1 2`, `2 1`, `2 2`의 순열이 출력됩니다.
