# [백준 15650: 백트래킹 n,m(2)](https://www.acmicpc.net/problem/15650)
백준 15650번 문제는 **"N과 M (2)"**로, **백트래킹**을 이용하여 **1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열**을 구하는 문제입니다. 이 문제는 **오름차순**으로 수열을 구성해야 한다는 조건이 추가되어 있습니다.

### 문제 설명

- 1부터 N까지의 자연수 중에서 **M개**를 고른 **중복 없는 조합**을 구하는 문제입니다.
- **수열은 오름차순**으로 출력해야 합니다.
- 중복을 허용하지 않으며, 같은 숫자가 여러 번 선택되면 안 됩니다.

### 입력

- 첫째 줄에 자연수 N과 M이 주어집니다. (1 ≤ M ≤ N ≤ 8)

### 출력

- 한 줄에 하나씩 문제의 조건을 만족하는 **수열**을 출력해야 합니다.
- 각 수열은 공백으로 구분된 M개의 숫자로 이루어져 있으며, **수열은 오름차순**이어야 합니다.

### 예시

### 입력 1:

```
코드 복사
3 1

```

### 출력 1:

```
코드 복사
1
2
3

```

### 입력 2:

```
코드 복사
4 2

```

### 출력 2:

```
코드 복사
1 2
1 3
1 4
2 3
2 4
3 4

```

### 문제 분석

이 문제는 주어진 자연수 N에서 M개를 선택하는 모든 경우의 수를 찾아야 하는데, 선택된 수열은 오름차순이어야 합니다. 즉, 한 번 선택된 수는 다시 선택되지 않으며, 이전에 선택된 수보다 작은 수를 선택할 수 없습니다.

### 풀이 방법

이 문제는 **백트래킹** 기법을 사용하여 해결할 수 있습니다. 백트래킹은 DFS를 기반으로 하여 모든 가능한 수를 탐색하지만, 문제 조건에 맞지 않는 경우에는 가지를 쳐서 더 이상 탐색하지 않도록 합니다.

### 백트래킹의 핵심 아이디어

- 현재까지 선택한 숫자의 마지막 수보다 큰 숫자만 다음에 선택합니다. 이를 통해 **오름차순**으로 수열을 생성할 수 있습니다.
- 중복되지 않도록 **방문한 수는 다시 방문하지 않음**으로써 문제의 제약 조건을 만족시킵니다.

### 코드 설명

```python
python
코드 복사
def backtrack(start, depth):
    # 수열의 길이가 M에 도달하면 출력
    if depth == M:
        print(' '.join(map(str, result)))
        return

    # start부터 N까지의 숫자들을 탐색
    for i in range(start, N + 1):
        result.append(i)  # 숫자를 선택
        backtrack(i + 1, depth + 1)  # 다음 단계로 이동 (다음 수는 i보다 커야 함)
        result.pop()  # 백트래킹: 선택한 숫자를 다시 제거

# 입력 받기
N, M = map(int, input().split())
result = []

# 백트래킹 시작
backtrack(1, 0)

```

### 코드 설명

1. **backtrack(start, depth)** 함수는 현재 수열에서 선택할 수 있는 시작 숫자(start)와 현재까지 선택한 숫자의 개수(depth)를 인자로 받습니다.
2. **depth == M**이 되면, M개의 숫자가 선택된 것이므로 **출력**합니다.
3. 그 외의 경우, 반복문을 통해 **start부터 N까지**의 숫자 중에서 하나씩 선택하여 수열을 만듭니다.
4. 선택한 숫자는 리스트 **result**에 저장하고, 백트래킹 재귀 호출을 통해 다음 숫자를 선택합니다. 이때 다음에 선택할 수 있는 숫자는 **i + 1**부터 시작하여 오름차순을 유지합니다.
5. 재귀 호출이 끝나면, 마지막에 선택한 숫자를 **result에서 제거(pop)**하여 다시 다른 경로를 탐색할 수 있게 합니다.

### 주요 포인트

- **오름차순 조건**: `backtrack(i + 1, depth + 1)`에서 다음 숫자가 현재 선택한 숫자보다 크게 설정되므로, 오름차순 조건을 자연스럽게 만족합니다.
- **중복 방지**: 숫자를 다시 사용하지 않기 위해서 이미 선택한 숫자는 리스트에 포함하지 않습니다.

### 예시

### 입력:

```
코드 복사
4 2

```

### 과정:

1. 첫 번째 단계에서 1을 선택하고, 이후 2, 3, 4를 선택하는 방식으로 계속 재귀 탐색을 진행합니다.
2. 1을 선택한 후에는 1보다 큰 수인 2, 3, 4를 선택할 수 있습니다.
3. 2를 선택하면 3, 4 중에서 다음 숫자를 선택하는 식으로 진행됩니다.

출력 결과는 다음과 같습니다:

```
코드 복사
1 2
1 3
1 4
2 3
2 4
3 4

```

### 마무리

백트래킹을 이용하여 주어진 조건을 만족하는 모든 수열을 구하는 문제입니다. 수열을 오름차순으로 만들기 위해 재귀 호출에서 시작 인덱스를 `i + 1`로 설정하는 것이 핵심입니다.

## return 은 저기서 무슨 역할?

`return`의 역할은 **재귀 호출의 종료**를 의미합니다. 즉, 특정 조건을 만족했을 때 더 이상의 재귀 호출을 진행하지 않고 함수를 종료하는 역할을 합니다.

### 다시 한 번 코드 분석:

```python
n, m = map(int, input().split())

sequence = []  # 수열을 저장할 리스트

def dfs(start):
    if len(sequence) == m:  # 수열의 길이가 m에 도달했을 때 출력
        print(' '.join(map(str, sequence)))
        return
    
    for i in range(start, n + 1):  # 현재 start부터 n까지의 숫자들 탐색
        sequence.append(i)  # i를 수열에 추가
        dfs(i + 1)  # 다음 재귀에서는 i보다 큰 숫자만 선택 가능 (오름차순 유지)
        sequence.pop()  # 재귀에서 돌아오면 마지막에 추가한 숫자를 pop하여 상태를 원래대로 되돌림

dfs(1)  # 1부터 탐색 시작

```

### `return`의 역할:

1. **종료 조건**:
    - `if len(sequence) == m:` 이 조건이 만족되면, 현재 `sequence`의 길이가 `m`에 도달한 상태입니다. 즉, 수열을 완성한 상태입니다.
    - 이때, 수열을 출력한 후 더 이상 탐색을 할 필요가 없기 때문에 `return`을 통해 재귀 함수를 **종료**하고 호출된 함수로 되돌아갑니다.
2. **재귀 호출의 중단**:
    - `dfs` 함수는 매번 숫자를 추가한 후 다시 **다음 숫자를 선택**하기 위해 재귀 호출을 하게 됩니다. 그런데 수열이 이미 완성되었으면 (길이가 `m`이면) 더 이상 재귀 호출이 필요하지 않기 때문에, 더 깊이 들어가지 않고 함수 실행을 중단해야 합니다.
    - 만약 `return`이 없다면, 이미 완성된 수열이 출력된 이후에도 계속해서 재귀 호출이 진행되면서 불필요한 탐색이 이루어질 수 있습니다. 이는 **중복된 결과**를 출력하거나 **잘못된 탐색**을 진행하게 할 수도 있습니다.

### `return`의 구체적인 동작 예시:

만약 `n=4, m=2`인 경우를 예로 들어봅시다:

1. **첫 번째 재귀 호출 (dfs(1))**:
    - `sequence = [1]`
    - `dfs(2)`로 재귀 호출.
2. **두 번째 재귀 호출 (dfs(2))**:
    - `sequence = [1, 2]`
    - 이때, 수열의 길이가 `m = 2`와 같으므로 `print('1 2')` 출력.
    - 출력 후 `return`이 실행되면, 더 이상 재귀 호출이 진행되지 않고 **이전 재귀 호출**로 돌아갑니다.
3. **이전 호출로 돌아가서 (dfs(1))**:
    - 다시 돌아와서, `sequence.pop()`이 호출되어 **`sequence = [1]`*이 되고, 이제 `i = 3`을 선택하게 됩니다.
    - `dfs(3)`으로 재귀 호출이 진행되고, 같은 방식으로 새로운 수열이 출력됩니다.

이러한 흐름에서 `return`은 수열이 완성되었을 때 재귀 호출을 종료하고 **백트래킹을 가능하게 만들어줍니다**.

[**백준 문제 15654번: N과 M (5) 총정리**](https://www.notion.so/15654-N-M-5-128900cfb74d8063a908c77785c2c20e?pvs=21)
